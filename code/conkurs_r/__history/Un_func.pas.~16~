unit Un_func;

interface
uses
dateUtils,
sysUtils,
Controls,
Classes,
Graphics,
Dialogs,
Forms,
StdCtrls,
IniFiles,
ComCtrls,
DBCtrls,
Windows,
mask,
dbgrids,
StrUtils,
variants,
JPEG,
ImgList,
db,
adodb,
ComObj,
math,
ExtCtrls;
function AddNumbers(num1, num2: Integer): Integer; stdcall;
  external 'mylib.dll' name 'AddNumbers';
const
  crMyAnimatedCursor = 1;
const
  EM_LINEINDEX = $BB;
type
  TSysCharSet = set of Char;
  type
    symmx=array[1..255] of Byte;
var
  symcount:Integer;
var
  VisitedStaticTexts: TStringList;
function  DateToStr_(Dat : TDate): String;
function  CommaPoint (X: String) : String;
function  FindFormByName(const AName: string): TForm;
procedure SaveFormState(AForm: TForm);
procedure LoadFormState(AForm: TForm);
procedure UpdateFormProperties(const FormName: string;
  NewCaption: string = '';
  NewColor: TColor = clNone;
  NewWidth: Integer = -1;
  NewHeight: Integer = -1);
 procedure UniformizeComponentSizes(AComponent: TComponent; AWidth, AHeight:
 Integer; AColor: TColor; AFontName: string; AFontSize: Integer);
 procedure SaveConnectionStringToFile(const FileName, ConnectionString: string);
 function min3(a, b, c: integer): integer;
 function LeveDist(s, t: string): integer;
 function levi_checker(Str_one,str_two:string):Boolean;
 function NormalizeStringAndExtractParams2(var InputString: string;
 out p1, p2: string): Boolean;
 function NormalizeStringAndExtractParams3(var InputString: string; out p1, p2, p3:
 string): Boolean;
 function Capitalizer(str:string; mode:integer=0):string;
 function adr_fixer(str:string;  mode:Integer=0):string;
 procedure UniformizeDBGrids(AForm: TForm; const FontName: string;
 FontSize: Integer; FontColor: TColor; BkColor: TColor);
 function ValidateComponentText(AComponent: TWinControl;
 const AllowedChars: TSysCharSet): Boolean;
 function IsEnglishText(const Text: string): Boolean;
 Function IsValidEmail(const Email: string): Boolean;
 procedure LoadIconFromResource(const ResourceName: string;
 Action: Integer; ImageList: TImageList = nil);
 procedure HandleAnimatedCursor(Action: Integer; const FileName: string = '');
 procedure LoadImageFromResource(const ResourceName: string; Image: TImage);
 procedure CreateToolBarWithButtons(Form: TForm; ImageList: TImageList;
 const ButtonCaptions: array of string; const ButtonClicks: array of TNotifyEvent);
 function GetTimeOfDay: string;
 procedure ExtractResFile;
function FileExistsInAppDirectory(const FileName: string): string;
procedure UniformizeButtonsSize(AWinControl: TWinControl; AWidth,
AHeight: Integer);
function IsDigitsOnly(const Text: string): Boolean;
function is_cost_correct(var str: string): Boolean;
function GetCurrentDateTime: TDateTime;
function IsMaskEditEmpty(MaskEdit: TMaskEdit): Boolean;
procedure SetFormPropertiesIfNeeded;
function FindDataModuleByName(const AName: string): TDataModule;
procedure CloseAllQueriesOnDataModule(const DataModuleName: string);
procedure GenerateCSVFile(const FileName: string);
procedure GenerateXMLFile(const FileName: string);
procedure GenerateJSONFile(const FileName: string);
function SplitString(const S: string; const Delimiter: Char;
var ResultArray: array of string): Integer;
procedure LoadCSVToTableFromDialog(
  OpenDialog: TOpenDialog;
  const TableName: string;
  const FieldIdName, FieldNaimName, FieldPriceName: string;
  Query: TADOQuery
);
procedure LoadXMLToTableFromDialog(
  OpenDialog: TOpenDialog;
  const TableName: string;
  const FieldIdName, FieldNaimName, FieldPriceName: string;
  Query: TADOQuery
);
function RemoveXMLComments(const FileName: string): string;
procedure LoadJSONToTableFromDialog(
  OpenDialog: TOpenDialog;
  const TableName: string;
  const FieldIdName, FieldNaimName, FieldPriceName: string;
  Query: TADOQuery
);
procedure LoadTextFromResource(const ResourceName: string;
RichTextEdit: TRichEdit);
procedure FormatRichText(RichEdit: TRichEdit; FontSize: Integer; FontName: string;
TextColor: TColor; BulletStyle: Boolean; ReadOnly: Boolean; ScrollBars: TScrollStyle);
procedure MakeStaticTextLookLikeLink(
  AForm: TForm;
  const StaticTextName: string;
  OnMouseEnterEvent: TNotifyEvent;
  OnMouseLeaveEvent: TNotifyEvent;
  OnClickEvent: TNotifyEvent
);
procedure AlignComponentsVertically(AContainer: TWinControl;
Spacing: Integer = 5);
procedure CheckAndCreateHelpFolder;
procedure SaveRichEditToFile(RichEdit: TRichEdit; SaveDialog: TSaveDialog);
procedure AppendRichEditToIniFile(RichEdit: TRichEdit; const FileName: string);
procedure LoadTextFromFile(const FileName: string; RichTextEdit: TRichEdit);
 procedure GenerateMathQuiz(CaptchaLabel: TLabel; ResultLabel: TStaticText);
 procedure FormatPanelCaption(const PanelName: string; AForm: TForm;
  FontName: string; FontSize: Integer; FontColor: TColor);
  procedure CheckMathQuizAnswer(CaptchaLabel: TLabel; InputBox: TLabeledEdit;
 ResultLabel: TStaticText);
function get_rnd_char(symcount:Integer):string;
implementation
 var
  hAniCursor: HCURSOR = 0;

function    CommaPoint (X: String) : String;
var iii : Integer;
begin
 iii:=pos(',',X) ;
 if iii<>0 then
 Result:=copy(X,1,iii-1)+'.'+copy(X,iii+1,5)
 else
 Result:=x;
end;

function DateToStr_(Dat : TDate): String;
begin
  Result:= IntToStr(MonthOf(Dat))+'.'
  +IntToStr(DayOf(Dat))+'.'
  +IntToStr(YearOf(Dat));
end;

function FindFormByName(const AName: string): TForm;
var
  i: Integer;
begin
  Result := nil;
  for i := 0 to Screen.FormCount - 1 do
  begin
    if SameText(Screen.Forms[i].Name, AName) then
    begin
      Result := Screen.Forms[i];
      Break;
    end;
  end;
end;

procedure UpdateFormProperties(const FormName: string;
  NewCaption: string;
  NewColor: TColor;
  NewWidth: Integer;
  NewHeight: Integer);
var
  Form: TForm;
          var l:Integer;
          var b:Integer;
          var d:Integer;
begin
  Form := FindFormByName(FormName);
  if not Assigned(Form) then
  begin
    ShowMessageFmt('Форма "%s" не найдена!', [FormName]);
    Exit;
  end;

   with Form do
  begin
    if NewCaption <> '' then
      Caption := NewCaption;

    if NewColor <> clNone then
      Color := NewColor;

    if NewWidth > 0 then
      Width := NewWidth;

    if NewHeight > 0 then
      Height := NewHeight;
      form.Position:=poScreenCenter;
      for l := 0 to ComponentCount - 1 do
      begin
        if (Components[l] is TLabeledEdit ) then
        begin
          (Components[l] as TLabeledEdit).Clear;
        end;
  for b := 0 to ComponentCount - 1 do
  begin
    if (Components[b] is TButton) then
    begin
      (Components[b] as TButton).Anchors:=[akLeft,akRight];
    end;
      for d := 0 to ComponentCount - 1 do
  begin
    if (Components[d] is TDateTimePicker ) then
    begin
      (Components[d] as TDateTimePicker).Date:=Now;
    end;

  end;
      end;
    end;


  end;
end;
  procedure SaveFormState(AForm: TForm);
var
  IniFile: TIniFile;
  FileName: string;
begin

  FileName := ChangeFileExt(Application.ExeName, '.ini');

  IniFile := TIniFile.Create(FileName);
  try
    IniFile.WriteInteger(AForm.Name, 'Left', AForm.Left);
    IniFile.WriteInteger(AForm.Name, 'Top', AForm.Top);
    IniFile.WriteInteger(AForm.Name, 'Width', AForm.Width);
    IniFile.WriteInteger(AForm.Name, 'Height', AForm.Height);
  finally
    IniFile.Free;
  end;
end;

procedure LoadFormState(AForm: TForm);
var
  IniFile: TIniFile;
  FileName: string;
begin
  FileName := ChangeFileExt(Application.ExeName, '.ini');
  if not FileExists(FileName) then Exit;
  IniFile := TIniFile.Create(FileName);
  try
    AForm.Left := IniFile.ReadInteger(AForm.Name, 'Left', AForm.Left);
    AForm.Top := IniFile.ReadInteger(AForm.Name, 'Top', AForm.Top);
    AForm.Width := IniFile.ReadInteger(AForm.Name, 'Width', AForm.Width);
    AForm.Height := IniFile.ReadInteger(AForm.Name, 'Height', AForm.Height);
  finally
    IniFile.Free;
  end;
end;
 procedure UniformizeComponentSizes(AComponent: TComponent; AWidth,
 AHeight: Integer; AColor: TColor; AFontName: string; AFontSize: Integer);
var
  i: Integer;
  Control: TControl;
begin
  if AComponent is TControl then
  begin
    Control := TControl(AComponent);
    if Control is TLabeledEdit then
    begin
      TLabeledEdit(Control).Width := AWidth;
      TLabeledEdit(Control).Height := AHeight;
      TLabeledEdit(Control).Color := AColor;
      TLabeledEdit(Control).Font.Name := AFontName;
      TLabeledEdit(Control).Font.Size := AFontSize;
    end
    else if Control is TEdit then
    begin
      TEdit(Control).Width := AWidth;
      TEdit(Control).Height := AHeight;
      TEdit(Control).Color := AColor;
      TEdit(Control).Font.Name := AFontName;
      TEdit(Control).Font.Size := AFontSize;
    end
    else if Control is TDBLookupComboBox then
    begin
      TDBLookupComboBox(Control).Width := AWidth;
      TDBLookupComboBox(Control).Height := AHeight;
      TDBLookupComboBox(Control).Color := AColor;
      TDBLookupComboBox(Control).Font.Name := AFontName;
      TDBLookupComboBox(Control).Font.Size := AFontSize;
    end
    else if Control is TDateTimePicker then
    begin
      TDateTimePicker(Control).Width := AWidth;
      TDateTimePicker(Control).Height := AHeight;
      TDateTimePicker(Control).Color := AColor;
      TDateTimePicker(Control).Font.Name := AFontName;
      TDateTimePicker(Control).Font.Size := AFontSize;
    end
     else if Control  is TDBComboBox then
          begin
          TDBComboBox(Control).Width := AWidth;
          TDBComboBox(Control).Height := AHeight;
          TDBComboBox(Control).Color := AColor;
          TDBComboBox(Control).Font.Name := AFontName;
          TDBComboBox(Control).Font.Size := AFontSize;
          end
     else if Control  is TMaskEdit then
          begin
          TMaskEdit(Control).Width := AWidth;
          TMaskEdit(Control).Height := AHeight;
          TMaskEdit(Control).Color := AColor;
          TMaskEdit(Control).Font.Name := AFontName;
          TMaskEdit(Control).Font.Size := AFontSize;
     end
     else if Control  is TComboBox then
          begin
          TComboBox(Control).Width := AWidth;
          TComboBox(Control).Height := AHeight;
          TComboBox(Control).Color := AColor;
          TComboBox(Control).Font.Name := AFontName;
          TComboBox(Control).Font.Size := AFontSize;
          end;
  end;
  if AComponent is TWinControl then
  begin
    for i := 0 to TWinControl(AComponent).ControlCount - 1 do
    begin
      UniformizeComponentSizes(TWinControl(AComponent).Controls[i], AWidth,
      AHeight, AColor, AFontName, AFontSize);
    end;
  end;
end;

procedure SaveConnectionStringToFile(const FileName, ConnectionString: string);
var
  MFileStream: TextFile;
begin
  AssignFile(MFileStream, FileName);
  try
    Rewrite(MFileStream);
    Writeln(MFileStream, ConnectionString);
  finally
    CloseFile(MFileStream);
  end;
end;
const
 cuthalf = 100; // константа, ограничивающая макс. длину
  // обрабатываемых строк

var
  buf: array[0..((cuthalf * 2) - 1)] of integer; // рабочий буфер, заменяет
  // матрицу, представленную
  // в описании

function min3(a, b, c: integer): integer;
begin
  Result := a;
  if b < Result then
    Result := b;
  if c < Result then
    Result := c;
end;

// реализация функции в принципе соответствует описанию с одной оговоркой:
// матрица из описания заменена статическим буфером, длина которого
// равна удвоенной максимальной длине строк
// это сделано для 1) экономии памяти и во избежание её перераспределений
// 2) повышения быстродействия (у меня функция работает
// в обработчике onfilterRecord)
// таким образом, в реализации половинами буфера представлены только
// две последние строки матрицы, которые меняются местами каждую
// итерацию внешнего цикла (по i)... для определения того, какая из половин
// буфера является "нижней строкой", служит переменная flip
// т. е. при flip = false первая половина буфера является предпоследней
// строкой, а вторая - последней; при flip = true наоборот,
// первая половина - последняя строка, вторая половина - предпоследняя

function LeveDist(s, t: string): integer;
var
  i, j, m, n: integer;
  cost: integer;
  flip: boolean;
begin
  s := copy(s, 1, cuthalf - 1);
  t := copy(t, 1, cuthalf - 1);
  m := length(s);
  n := length(t);
  if m = 0 then
    Result := n
  else if n = 0 then
    Result := m
  else
  begin
    flip := false;
    for i := 0 to n do
      buf[i] := i;
    for i := 1 to m do
    begin
      if flip then
        buf[0] := i
      else
        buf[cuthalf] := i;
      for j := 1 to n do
      begin
        if s[i] = t[j] then
          cost := 0
        else
          cost := 1;
        if flip then
          buf[j] := min3((buf[cuthalf + j] + 1),
            (buf[j - 1] + 1),
            (buf[cuthalf + j - 1] + cost))
        else
          buf[cuthalf + j] := min3((buf[j] + 1),
            (buf[cuthalf + j - 1] + 1),
            (buf[j - 1] + cost));
      end;
      flip := not flip;
    end;
    if flip then
      Result := buf[cuthalf + n]
    else
      Result := buf[n];
  end;
end;

function levi_checker(Str_one,str_two:string):Boolean;
begin
 if (Trim(Str_one) = '') or (Trim(Str_two) = '') then
  begin
    Result := False;
    Exit;
  end;
  if LeveDist(Str_one, Str_two) = 0 then
    Result := True
  else
    Result := False;
end;


function NormalizeStringAndExtractParams2(var InputString: string; out p1, p2: string): Boolean;
var
  l: TStringList;
  i: Integer;
  NormalizedString: string;
begin
  Result := False;
  if Trim(InputString) = '' then
  begin
    MessageDlg('Строка пуста', mtError, [mbOK], 0);
    Exit;
  end;
  l := TStringList.Create;
  try
    l.Delimiter := ' ';
    l.StrictDelimiter := True;
    l.DelimitedText := InputString;
    NormalizedString := '';
    for i := 0 to l.Count - 1 do
    begin
      if Trim(l[i]) <> '' then
        NormalizedString := NormalizedString + ' ' + Trim(l[i]);
    end;
    NormalizedString := Trim(NormalizedString);
    if NormalizedString = '' then
    begin
      MessageDlg('Строка должна содержать минимум одно слово', mtError, [mbOK], 0);
      Exit;
    end;
    l.DelimitedText := NormalizedString;
    if l.Count >= 1 then p1 := l.Strings[0] else p1 := '';
    if l.Count >= 2 then p2 := l.Strings[1] else p2 := '';
    InputString := NormalizedString;
    Result := True;
  finally
    FreeAndNil(l);
  end;
end;

function NormalizeStringAndExtractParams3(var InputString: string; out p1, p2, p3:
string): Boolean;
var
  l: TStringList;
  i: Integer;
  NormalizedString: string;
begin
  Result := False;
  if Trim(InputString) = '' then
  begin
    MessageDlg('Строка пуста', mtError, [mbOK], 0);
    Exit;
  end;


  l := TStringList.Create;
  try
    l.Delimiter := ' ';
    l.StrictDelimiter := True;
    l.DelimitedText := InputString;


    NormalizedString := '';
    for i := 0 to l.Count - 1 do
    begin
      if Trim(l[i]) <> '' then
        NormalizedString := NormalizedString + ' ' + Trim(l[i]);
    end;
    NormalizedString := Trim(NormalizedString);


    if NormalizedString = '' then
    begin
      MessageDlg('Строка должна содержать минимум одно слово', mtError, [mbOK], 0);
      Exit;
    end;


    l.DelimitedText := NormalizedString;
    if l.Count >= 1 then p1 := l.Strings[0] else p1 := '';
    if l.Count >= 2 then p2 := l.Strings[1] else p2 := '';
    if l.Count >= 3 then p3 := l.Strings[2] else p3 := '';


    InputString := NormalizedString;
    Result := True;
  finally
    FreeAndNil(l);
  end;
end;
function Capitalizer(str:string; mode:integer=0):string;
begin
  if (Trim(str)='')and(mode=0) then
  begin
    Result:='';
    ShowMessage('Строка пуста');
    Exit;
  end;
  case mode of
   0:
   begin
    str:=TrimLeft(str);
    Result:=Concat(AnsiUpperCase(str[1]),
    AnsiLowerCase(Copy(str, 2, length(str))));
   end;
   1:
   begin
     Result :=str;
     Exit;
   end;
  end;// case
end;

function adr_fixer(str:string; mode:Integer=0):string;
 var head_str:string;
begin
if (trim(str)='') then
begin
  head_str:='';
  Result:='';
  ShowMessage('строка пуста');
  Exit;
end;
case mode  of
0:
begin
  if not(trim(str)='') then
   begin
    str:=Trim(str);
      str := Trim(str);
      if Pos('Ул.', str) = 1 then
        Delete(str, 1, 3);
      if Pos('Пр.', str) = 1 then
        Delete(str, 1, 3);
      if Pos('Проезд', str) = 1 then
        Delete(str, 1, 6);
      Result := Trim(str);
   end
   else
   begin
    head_str:='';
  Result:='';
  ShowMessage('строка пуста');
   end;
end;
1:
begin
  head_str:='Ул.';
  result:=Concat(head_str, str);
end;
2:
begin
  head_str:='Пр.';
  result:=Concat(head_str, str);
end;
3:
begin
  head_str:='Проезд ';
  result:=Concat(head_str, str);
end;
end;      //case
end;
procedure UniformizeDBGrids(AForm: TForm; const FontName: string;
FontSize: Integer; FontColor: TColor; BkColor: TColor);
var
  i: Integer;
  DBGrid: TDBGrid;
begin
  for i := 0 to AForm.ComponentCount - 1 do
  begin
    if AForm.Components[i] is TDBGrid then
    begin
      DBGrid := TDBGrid(AForm.Components[i]);
      DBGrid.Font.Name := FontName;
      DBGrid.Font.Size := FontSize;
      DBGrid.Font.Color := FontColor;
      DBGrid.Color := BkColor;
      DBGrid.Options := DBGrid.Options +
      [dgTitles, dgIndicator, dgColumnResize, dgColLines, dgRowLines, dgTabs];
      DBGrid.DefaultDrawing := True;
      DBGrid.ReadOnly := True;
      DBGrid.Refresh;
    end;
  end;
end;
function ValidateComponentText(AComponent: TWinControl;
 const AllowedChars: TSysCharSet): Boolean;
var
  Text: string;
  i: Integer;
  CharIsValid: Boolean;
begin
  Result := True;
  if AComponent is TLabeledEdit then
    Text := TLabeledEdit(AComponent).Text
  else if AComponent is TEdit then
    Text := TEdit(AComponent).Text;
  for i := 1 to Length(Text) do
  begin
    CharIsValid := Text[i] in AllowedChars;
    if not CharIsValid then
    begin
      ShowMessage('Недопустимый символ в компоненте: ' + AComponent.Name);
      Result := False;
      Exit;
    end;
  end;
end;
function IsEnglishText(const Text: string): Boolean;
var
  i: Integer;
begin
  Result := True;

  for i := 1 to Length(Text) do
  begin
    if not (Text[i] in ['a'..'z', 'A'..'Z', '0'..'9', '@', '.', '_', '-']) then
    begin
      Result := False;
      Exit;
    end;
  end;
end;
Function IsValidEmail(const Email: string): Boolean;
var
AtPos, DotPos: Integer;
begin
Result := False;
if not IsEnglishText(Email) then
begin
ShowMessage('Ошибка: текст должен быть на английском языке');
Exit;
end;
AtPos := Pos('@', Email);
if AtPos = 0 then
begin
ShowMessage('Ошибка: отсутствует символ "@"');
Exit;
end;
if (AtPos = 1) or (AtPos = Length(Email)) then
begin
ShowMessage('Ошибка: символ "@" находится в неправильной позиции');
Exit;
end;
DotPos := PosEx('.', Email, AtPos);
if DotPos = 0 then
begin
ShowMessage('Ошибка: отсутствует точка после "@"');
Exit;
end;
if DotPos = Length(Email) then
begin
ShowMessage('Ошибка: точка находится в конце строки');
Exit;
end;
Result := True;
end;
procedure HandleAnimatedCursor(Action: Integer; const FileName: string = '');
begin
  case Action of
    0:
    begin

      if not FileExists(FileName) then
        raise Exception.Create('Файл курсора не найден: ' + FileName);
      if hAniCursor <> 0 then
      begin
        DestroyCursor(hAniCursor);
        hAniCursor := 0;
      end;
      hAniCursor := LoadImage(
        0,
        PChar(FileName),
        IMAGE_CURSOR,
        0,
        0,
        LR_LOADFROMFILE or LR_DEFAULTSIZE or LR_SHARED
      );

      if hAniCursor = 0 then
        raise Exception.Create('Ошибка загрузки курсора');
      Screen.Cursors[crMyAnimatedCursor] := hAniCursor;
      Screen.Cursor := crMyAnimatedCursor;
    end;
    1:
    begin
      if hAniCursor = 0 then
        raise Exception.Create('Курсор не загружен');
      Screen.Cursor := crMyAnimatedCursor;
    end;
    2:
    begin
      Screen.Cursor := crDefault;
    end;
    3:
    begin
      if hAniCursor <> 0 then
        DestroyCursor(hAniCursor);
      hAniCursor := 0;
      Screen.Cursor := crDefault;
    end;
  end;
end;

procedure LoadIconFromResource(const ResourceName: string;
Action: Integer; ImageList: TImageList = nil);
var
  RS: TResourceStream;
  Icon: TIcon;
begin
  Icon := TIcon.Create;
  try

    RS := TResourceStream.Create(HInstance, ResourceName, RT_RCDATA);
    try

      Icon.LoadFromStream(RS);


      case Action of
        0:
          Application.Icon := Icon;

        1:
          if Assigned(ImageList) then
            ImageList.AddIcon(Icon)
          else
            raise Exception.Create('Ошибка: ImageList не назначен.');

        else
          raise Exception.Create('Ошибка: Неизвестное действие.');
      end;
    finally
      RS.Free;
    end;
  finally
    Icon.Free;
  end;
end;
procedure LoadImageFromResource(const ResourceName: string; Image: TImage);
var
  RS: TResourceStream;
  JPEG: TJPEGImage;
begin
  if not Assigned(Image) then
    raise Exception.Create('Ошибка: Компонент TImage не назначен.');
  RS := nil;
  JPEG := nil;
  try
    RS := TResourceStream.Create(HInstance, ResourceName, RT_RCDATA);
    JPEG := TJPEGImage.Create;
    try
      JPEG.LoadFromStream(RS);
      Image.Picture.Assign(JPEG);
    except
      on E: Exception do
        raise Exception.CreateFmt('Ошибка загрузки изображения "%s": %s', [ResourceName, E.Message]);
    end;
  finally

    if Assigned(RS) then
      RS.Free;
    if Assigned(JPEG) then
      JPEG.Free;
  end;
end;
procedure CreateToolBarWithButtons(Form: TForm; ImageList: TImageList;
  const ButtonCaptions: array of string; const ButtonClicks: array of TNotifyEvent);
var
  ToolBar: TToolBar;
  Button: TToolButton;
  i: Integer;
begin
  // Проверка входных параметров
  if not Assigned(Form) then
    raise Exception.Create('Ошибка: Форма не назначена.');
  if not Assigned(ImageList) then
    raise Exception.Create('Ошибка: ImageList не назначен.');

  // Создание TToolBar
  ToolBar := TToolBar.Create(Form);
  ToolBar.Parent := Form;
  ToolBar.Align := alTop;
  ToolBar.ShowCaptions := True;
  ToolBar.Images := ImageList;

  // Создание кнопок
  for i := 0 to High(ButtonCaptions) do
  begin
    Button := TToolButton.Create(ToolBar);
    Button.Parent := ToolBar;
    Button.ImageIndex := i; // Назначение индекса картинки из ImageList
    Button.Caption := ButtonCaptions[i]; // Установка подписи кнопки
    Button.Hint := ButtonCaptions[i]; // Подсказка для кнопки
    Button.ShowHint := True; // Включение подсказок
    Button.Tag := i; // Уникальный идентификатор кнопки

    // Назначение обработчика события
    if i <= High(ButtonClicks) then
      Button.OnClick := ButtonClicks[i]
    else
      Button.OnClick := nil; // Если обработчик не задан
  end;
end;
function GetTimeOfDay: string;
var
  CurrentHour: Word;
  CurrentMinute: Word;
  CurrentSecond: Word;
begin
  // Получаем текущее системное время
  DecodeTime(Now, CurrentHour, CurrentMinute, CurrentSecond, CurrentSecond);

  // Определяем время суток
  if (CurrentHour >= 6) and (CurrentHour < 12) then
    Result := 'Утро'
  else if (CurrentHour >= 12) and (CurrentHour < 18) then
    Result := 'День'
  else if (CurrentHour >= 18) and (CurrentHour < 24) then
    Result := 'Вечер'
  else
    Result := 'Ночь';
end;
procedure ExtractResFile;
var
  ResHandle: HRSRC;
  ResGlobal: HGLOBAL;
  ResPtr: Pointer;
  ResSize: DWORD;
  FileStream: TFileStream;
  OutputFileName: string;
begin
  ResHandle := FindResource(HInstance, 'RYK', RT_RCDATA);
  if ResHandle = 0 then
    raise Exception.Create('Ресурс не найден');
  ResGlobal := LoadResource(HInstance, ResHandle);
  if ResGlobal = 0 then
    raise Exception.Create('Ошибка загрузки ресурса');
  ResPtr := LockResource(ResGlobal);
  ResSize := SizeofResource(HInstance, ResHandle);
  if (ResPtr = nil) or (ResSize = 0) then
    raise Exception.Create('Ошибка доступа к данным ресурса');
  OutputFileName := ExtractFilePath(ParamStr(0)) + 'ryk.wav';
  FileStream := TFileStream.Create(OutputFileName, fmCreate);
  try
    FileStream.WriteBuffer(ResPtr^, ResSize);
  finally
    FileStream.Free;
  end;
end;

function FileExistsInAppDirectory(const FileName: string): string;
var
  SearchRec: TSearchRec;
  FindResult: Integer;
begin
  Result := '';  // Если файл не найден, возвращаем пустую строку
  FindResult := FindFirst(ExtractFilePath(ParamStr(0)) + FileName, faAnyFile, SearchRec);
  if FindResult = 0 then
  begin
    if (SearchRec.Attr and faDirectory = 0) then
      Result := SearchRec.Name;
  end;
end;
procedure UniformizeButtonsSize(AWinControl: TWinControl; AWidth, AHeight: Integer);
var
  i: Integer;
  Control: TControl;
begin
  for i := 0 to AWinControl.ControlCount - 1 do
  begin
    Control := AWinControl.Controls[i];
    if Control is TButton then
    begin
      TButton(Control).Width := AWidth;
      TButton(Control).Height := AHeight;
    end;
    if Control is TWinControl then
      UniformizeButtonsSize(TWinControl(Control), AWidth, AHeight);
  end;
end;
function IsDigitsOnly(const Text: string): Boolean;
var
  i: Integer;
  NumberValue: Int64; // Для больших чисел (до 18 цифр)
begin
  Result := True;

  // Проверяем каждый символ
  for i := 1 to Length(Text) do
  begin
    if not (Text[i] in ['0'..'9']) then // Разрешены только цифры
    begin
      ShowMessage('Ошибка: значение должно содержать только цифры.');
      Result := False;
      Exit;
    end;
  end;

  // Проверяем, что строка не пустая
  if Text = '' then
  begin
    ShowMessage('Ошибка: введите корректное число.');
    Result := False;
    Exit;
  end;

  // Преобразуем строку в целое число
  try
    NumberValue := StrToInt64(Text); // Для поддержки 18-значных чисел
    // Проверка диапазона (если нужно)
    if (NumberValue < 0) or (NumberValue > 999999999999999999) then // 10^18 - 1
    begin
      ShowMessage('Ошибка: значение должно быть в диапазоне от 0 до 999999999999999999.');
      Result := False;
      Exit;
    end;
  except
    on E: EConvertError do
    begin
      ShowMessage('Ошибка: неверный формат числа.');
      Result := False;
      Exit;
    end;
  end;
end;
function is_cost_correct(var str: string): Boolean;
var
  i: Integer;
begin
  Result := False;
  str := Trim(str);
  
  // Проверка на пустую строку
  if str = '' then
  begin
    ShowMessage('Строка пуста');
    Exit;
  end;
  
  // Проверка, что все символы — цифры
  for i := 1 to Length(str) do
  begin
    if not (str[i] in ['0'..'9']) then
    begin
      ShowMessage('Разрешён ввод только цифр');
      {$IFDEF MSWINDOWS}
      Windows.Beep(500, 100);
      {$ENDIF}
      Exit;
    end;
  end;
  
  // Проверка на длину числа (не более 3 знаков)
  if Length(str) >= 4 then  // Изменено условие с = на >=
  begin
    ShowMessage('Ошибка: число не должно содержать четыре и более цифр');  // Обновлено сообщение
    {$IFDEF MSWINDOWS}
    Windows.Beep(500, 100);
    {$ENDIF}
    Exit;
  end;
  
  // Если все проверки пройдены
  ShowMessage('Цена корректна');
  Result := True;
end;
function GetCurrentDateTime: TDateTime;
begin
  Result := Now; // Возвращает дату и время
end;
function GetDefaultMaskText(EditMask: string): string;
var
  i: Integer;
  InEscape: Boolean;
begin
  Result := '';
  InEscape := False;
  for i := 1 to Length(EditMask) do
  begin
    if InEscape then
    begin
      Result := Result + EditMask[i];
      InEscape := False;
    end
    else
    begin
      case EditMask[i] of
        '\': InEscape := True; // Экранированные символы
        '9', '0', 'L', 'A', 'a', 'C', 'c': Result := Result + ' '; // Заполнители
        else
          Result := Result + EditMask[i]; // Статические символы
      end;
    end;
  end;
end;
function IsMaskEditEmpty(MaskEdit: TMaskEdit): Boolean;
var
  CleanText: string;
begin
  // Удаляем статические символы и заполнители
  CleanText := MaskEdit.Text;
  CleanText := StringReplace(CleanText, '_', '', [rfReplaceAll]);
  CleanText := StringReplace(CleanText, '+7', '', [rfReplaceAll]);
  CleanText := StringReplace(CleanText, '(', '', [rfReplaceAll]);
  CleanText := StringReplace(CleanText, ')', '', [rfReplaceAll]);
  CleanText := StringReplace(CleanText, '-', '', [rfReplaceAll]);
  CleanText := StringReplace(CleanText, ' ', '', [rfReplaceAll]);
  Result := Trim(CleanText) = '';
end;
procedure SetFormPropertiesIfNeeded;
var
  Form: TForm;
begin
  Form := FindFormByName('frm_main');
  if Assigned(Form) then
  begin
    // Если форма найдена, задаем ей параметры
    Form.Width := 1024;
    Form.Height := 768;
    Form.Position := poScreenCenter;
  end
  else
  begin
    ShowMessage('Форма frm_main не найдена!');
  end;
end;
function FindDataModuleByName(const AName: string): TDataModule;
var
  i: Integer;
begin
  Result := nil;
  for i := 0 to Screen.DataModuleCount - 1 do
  begin
    if SameText(Screen.DataModules[i].Name, AName) then
    begin
      Result := Screen.DataModules[i];
      Break;
    end;
  end;
end;
procedure CloseAllQueriesOnDataModule(const DataModuleName: string);
var
  DataModule: TDataModule;
  Q: Integer;
  Query: TADOQuery;
begin
  DataModule := FindDataModuleByName(DataModuleName);
  if not Assigned(DataModule) then
  begin
    ShowMessage('Модуль данных ' + DataModuleName + ' не найден');
    Exit;
  end;
  for Q := 0 to DataModule.ComponentCount - 1 do
  begin
    if DataModule.Components[Q] is TADOQuery then
    begin
      Query := TADOQuery(DataModule.Components[Q]);
      try
        if Query.Active then
          Query.Close;
      except
        on E: Exception do
        begin
          ShowMessageFmt('Ошибка при закрытии запроса "%s": %s', [Query.Name, E.Message]);
        end;
      end;
    end;
  end;
end;

procedure GenerateCSVFile(const FileName: string);
var
  CSVData: TStringList;
  i: Integer;
  SampleGoods: array[1..5] of record
    id_good: Integer;
    naim_good: string;
    price_good: Double;
  end;
begin
  CSVData := TStringList.Create;
  try
    CSVData.Add('id_good,naim_good,price_good');
    SampleGoods[1].id_good := 1; SampleGoods[1].naim_good := 'Товар 1'; SampleGoods[1].price_good := 100.50;
    SampleGoods[2].id_good := 2; SampleGoods[2].naim_good := 'Товар 2'; SampleGoods[2].price_good := 200.75;
    SampleGoods[3].id_good := 3; SampleGoods[3].naim_good := 'Товар 3'; SampleGoods[3].price_good := 150.00;
    SampleGoods[4].id_good := 4; SampleGoods[4].naim_good := 'Товар 4'; SampleGoods[4].price_good := 300.25;
    SampleGoods[5].id_good := 5; SampleGoods[5].naim_good := 'Товар 5'; SampleGoods[5].price_good := 400.00;
    for i := 1 to 5 do
    begin
      CSVData.Add(Format('%d,%s,%.2f', [
        SampleGoods[i].id_good,
        SampleGoods[i].naim_good,
        SampleGoods[i].price_good
      ]));
    end;
    CSVData.SaveToFile(FileName);
    ShowMessage('CSV-файл успешно создан: ' + FileName);
  except
    on E: Exception do
      ShowMessage('Ошибка при создании CSV-файла: ' + E.Message);
  end;
end;
procedure GenerateXMLFile(const FileName: string);
var
  XMLData: TStringList;
  i: Integer;
  SampleGoods: array[1..5] of record
    id_good: Integer;
    naim_good: string;
    price_good: Double;
  end;
begin
  XMLData := TStringList.Create;
  try
    XMLData.Add('<?xml version="1.0" encoding="UTF-8"?>');
    XMLData.Add('<goods>');
    SampleGoods[1].id_good := 1; SampleGoods[1].naim_good := 'Товар 1'; SampleGoods[1].price_good := 100.50;
    SampleGoods[2].id_good := 2; SampleGoods[2].naim_good := 'Товар 2'; SampleGoods[2].price_good := 200.75;
    SampleGoods[3].id_good := 3; SampleGoods[3].naim_good := 'Товар 3'; SampleGoods[3].price_good := 150.00;
    SampleGoods[4].id_good := 4; SampleGoods[4].naim_good := 'Товар 4'; SampleGoods[4].price_good := 300.25;
    SampleGoods[5].id_good := 5; SampleGoods[5].naim_good := 'Товар 5'; SampleGoods[5].price_good := 400.00;
    for i := 1 to 5 do
    begin
      XMLData.Add('  <good>');
      XMLData.Add('    <id_good>' + IntToStr(SampleGoods[i].id_good) + '</id_good>');
      XMLData.Add('    <naim_good>' + SampleGoods[i].naim_good + '</naim_good>');
      XMLData.Add('    <price_good>' + FloatToStr(SampleGoods[i].price_good) + '</price_good>');
      XMLData.Add('  </good>');
    end;
    XMLData.Add('</goods>');
    XMLData.SaveToFile(FileName);
    ShowMessage('XML-файл успешно создан: ' + FileName);
  except
    on E: Exception do
      ShowMessage('Ошибка при создании XML-файла: ' + E.Message);
  end;
end;

procedure GenerateJSONFile(const FileName: string);
var
  JSONData: TStringList;
  i: Integer;
  SampleGoods: array[1..5] of record
    id_good: Integer;
    naim_good: string;
    price_good: Double;
  end;
begin
  JSONData := TStringList.Create;
  try
    JSONData.Add('[');
    SampleGoods[1].id_good := 1; SampleGoods[1].naim_good := 'Товар 1'; SampleGoods[1].price_good := 100.50;
    SampleGoods[2].id_good := 2; SampleGoods[2].naim_good := 'Товар 2'; SampleGoods[2].price_good := 200.75;
    SampleGoods[3].id_good := 3; SampleGoods[3].naim_good := 'Товар 3'; SampleGoods[3].price_good := 150.00;
    SampleGoods[4].id_good := 4; SampleGoods[4].naim_good := 'Товар 4'; SampleGoods[4].price_good := 300.25;
    SampleGoods[5].id_good := 5; SampleGoods[5].naim_good := 'Товар 5'; SampleGoods[5].price_good := 400.00;
    for i := 1 to 5 do
    begin
      JSONData.Add('  {');
      JSONData.Add('    "id_good": ' + IntToStr(SampleGoods[i].id_good) + ',');
      JSONData.Add('    "naim_good": "' + SampleGoods[i].naim_good + '",');
      JSONData.Add('    "price_good": ' + FloatToStr(SampleGoods[i].price_good));
      if i < 5 then
        JSONData.Add('  },')
      else
        JSONData.Add('  }'); 
    end;
    JSONData.Add(']');
    JSONData.SaveToFile(FileName);
    ShowMessage('JSON-файл успешно создан: ' + FileName);
  except
    on E: Exception do
      ShowMessage('Ошибка при создании JSON-файла: ' + E.Message);
  end;
end;
function SplitString(const S: string; const Delimiter: Char;
var ResultArray: array of string): Integer;
var
  i, StartPos, DelimPos: Integer;
  Token: string;
begin
  StartPos := 1;
  Result := 0;

  for i := 0 to High(ResultArray) do
    ResultArray[i] := ''; 

  while (StartPos <= Length(S)) and (Result <= High(ResultArray)) do
  begin
    DelimPos := Pos(Delimiter, Copy(S, StartPos, MaxInt));
    if DelimPos > 0 then
    begin
      Token := Copy(S, StartPos, DelimPos - 1);
      StartPos := StartPos + DelimPos;
    end
    else
    begin
      Token := Copy(S, StartPos, MaxInt);
      StartPos := Length(S) + 1;
    end;

    ResultArray[Result] := Trim(Token);
    Inc(Result);
  end;
end;
procedure LoadCSVToTableFromDialog(
  OpenDialog: TOpenDialog;
  const TableName: string;
  const FieldIdName, FieldNaimName, FieldPriceName: string;
  Query: TADOQuery
);
var
  StringList: TStringList;
  i, FieldCount: Integer;
  Fields: array[0..2] of string;
  SId, SName, SPrice: string;
  ID: Integer;
  Price: Double;
  Fmt: TFormatSettings;
begin
  if not Assigned(OpenDialog) then Exit;
  if not OpenDialog.Execute then
    Exit;
  ID := 0;
  Price := 0.0;
  StringList := TStringList.Create;
  try
    GetLocaleFormatSettings(0, Fmt);    Fmt.DecimalSeparator := '.';
    StringList.LoadFromFile(OpenDialog.FileName);
    with Query do
    begin
      Close;
      SQL.Text := 'DELETE FROM ' + TableName;
      ExecSQL;
    end;
    for i := 1 to StringList.Count - 1 do
    begin
      FieldCount := SplitString(StringList[i], ',', Fields);
      if FieldCount < 3 then Continue;
      SId := Fields[0];
      SName := Fields[1];
      SPrice := Fields[2];
      try
        ID := StrToIntDef(Trim(SId), 0);
        Price := StrToFloat(Trim(SPrice), Fmt);
      except
        Continue;
      end;
      with Query do
      begin
        Close;
        SQL.Text := Format(
          'INSERT INTO %s (%s, %s, %s) VALUES (:%s, :%s, :%s)',
          [TableName, FieldIdName, FieldNaimName, FieldPriceName,
           FieldIdName, FieldNaimName, FieldPriceName]
        );
        Parameters.ParamByName(FieldIdName).Value := ID;
        Parameters.ParamByName(FieldNaimName).Value := Trim(SName);
        Parameters.ParamByName(FieldPriceName).Value := Price;
        ExecSQL;
      end;
    end;
      with Query do
begin
  Close;
  SQL.Text := 'SELECT * FROM ' + TableName;
  Open;
end;
    ShowMessage('Данные успешно загружены из файла: ' + OpenDialog.FileName);
  finally
    StringList.Free;
  end;
end;
 function RemoveXMLComments(const FileName: string): string;
var
  SL: TStringList;
  XMLText: string;
  StartPos, EndPos: Integer;
begin
  SL := TStringList.Create;
  try
    SL.LoadFromFile(FileName);
    XMLText := SL.Text;
    StartPos := Pos('<!--', XMLText);
    while StartPos > 0 do
    begin
      EndPos := Pos('-->', Copy(XMLText, StartPos + 4, Length(XMLText)));
      if EndPos > 0 then
      begin
        EndPos := EndPos + StartPos + 3; // учёт сдвига
        Delete(XMLText, StartPos, EndPos - StartPos + 1);
      end
      else
        Break; // нет закрывающего комментария
      StartPos := Pos('<!--', XMLText);
    end;
    Result := XMLText;
  finally
    SL.Free;
  end;
end;
procedure LoadXMLToTableFromDialog(
  OpenDialog: TOpenDialog;
  const TableName: string;
  const FieldIdName, FieldNaimName, FieldPriceName: string;
  Query: TADOQuery
);
var
  XMLDoc: Variant;
  GoodsNode, GoodNode: Variant;
  i: Integer;
  ID: Integer;
  Price: Double;
  Fmt: TFormatSettings;
  SId, SName, SPrice: string;
  XMLString: string;
begin
  if not Assigned(OpenDialog) then Exit;
  if not OpenDialog.Execute then Exit;
  try
    XMLDoc := CreateOleObject('MSXML2.DOMDocument.6.0');
  except
    ShowMessage('Не удалось создать XML парсер. Убедитесь, что MSXML установлен.');
    Exit;
  end;
  XMLDoc.async := False;
  XMLDoc.preserveWhiteSpace := False;
  XMLString := RemoveXMLComments(OpenDialog.FileName);

  if not XMLDoc.loadXML(XMLString) then
  begin
    ShowMessage('Ошибка загрузки XML: ' + XMLDoc.parseError.reason);
    Exit;
  end;
  GoodsNode := XMLDoc.documentElement;
  if VarIsNull(GoodsNode) or (GoodsNode.nodeName <> 'goods') then
  begin
    ShowMessage('Неверный XML: ожидался <goods>');
    Exit;
  end;
  GetLocaleFormatSettings(1033, Fmt);
  Fmt.DecimalSeparator := '.';
  Fmt.ThousandSeparator := ',';
  Query.Close;
  Query.SQL.Text := 'DELETE FROM ' + TableName;
  Query.ExecSQL;

  Query.Connection.BeginTrans;
  try
    for i := 0 to GoodsNode.childNodes.length - 1 do
    begin
      GoodNode := GoodsNode.childNodes.item[i];
      if GoodNode.nodeName <> 'good' then Continue;

      try
        if not VarIsNull(GoodNode.selectSingleNode('id_good')) then
          SId := GoodNode.selectSingleNode('id_good').text else SId := '0';
        if not VarIsNull(GoodNode.selectSingleNode('naim_good')) then
          SName := GoodNode.selectSingleNode('naim_good').text else SName := '';
        if not VarIsNull(GoodNode.selectSingleNode('price_good')) then
          SPrice := GoodNode.selectSingleNode('price_good').text else SPrice := '0';
        SPrice := StringReplace(SPrice, ',', '.', [rfReplaceAll]);
        ID := StrToIntDef(Trim(SId), 0);
        Price := StrToFloat(Trim(SPrice), Fmt);
        Query.Close;
        Query.SQL.Text := Format(
          'INSERT INTO %s (%s, %s, %s) VALUES (:%s, :%s, :%s)',
          [TableName, FieldIdName, FieldNaimName, FieldPriceName,
           FieldIdName, FieldNaimName, FieldPriceName]
        );
        Query.Parameters.ParamByName(FieldIdName).Value := ID;
        Query.Parameters.ParamByName(FieldNaimName).Value := Trim(SName);
        Query.Parameters.ParamByName(FieldPriceName).Value := Price;
        Query.ExecSQL;
      except
        on E: Exception do
        begin
          ShowMessage('Ошибка при импорте ID=' + SId + ': ' + E.Message);
          Continue;
        end;
      end;
    end;
    Query.Connection.CommitTrans;
  except
    on E: Exception do
    begin
      Query.Connection.RollbackTrans;
      ShowMessage('Ошибка транзакции: ' + E.Message);
      Exit;
    end;
  end;
  Query.DisableControls;
  try
    Query.Close;
    Query.SQL.Text := 'SELECT * FROM ' + TableName;
    Query.Open;
  finally
    Query.EnableControls;
  end;
  ShowMessage('Импорт завершён. Загружено товаров: ' + IntToStr(GoodsNode.childNodes.length));
end;
procedure LoadJSONToTableFromDialog(
  OpenDialog: TOpenDialog;
  const TableName: string;
  const FieldIdName, FieldNaimName, FieldPriceName: string;
  Query: TADOQuery
);
var
  SL: TStringList;
  JSONText, Line, SId, SName, SPrice: string;
  i, ID: Integer;
  Price: Double;
  Fmt: TFormatSettings;
  Items: TStringList;
begin
  if not Assigned(OpenDialog) then Exit;
  OpenDialog.Filter := 'JSON файлы (*.json)|*.json';
  if not OpenDialog.Execute then Exit;

  SL := TStringList.Create;
  try
    SL.LoadFromFile(OpenDialog.FileName);
    JSONText := SL.Text;
  finally
    SL.Free;
  end;
  JSONText := StringReplace(JSONText, #13#10, '', [rfReplaceAll]);
  JSONText := StringReplace(JSONText, #10, '', [rfReplaceAll]);
  JSONText := StringReplace(JSONText, ' ', '', [rfReplaceAll]);
  JSONText := StringReplace(JSONText, '[', '', [rfReplaceAll]);
  JSONText := StringReplace(JSONText, ']', '', [rfReplaceAll]);
  JSONText := StringReplace(JSONText, '},{', '}|{', [rfReplaceAll]); // разделим объекты

  Items := TStringList.Create;
  try
    Items.Delimiter := '|';
    Items.StrictDelimiter := True;
    Items.DelimitedText := JSONText;

    GetLocaleFormatSettings(1033, Fmt);
    Fmt.DecimalSeparator := '.';
    Fmt.ThousandSeparator := ',';

    // Удалим старые записи
    Query.Close;
    Query.SQL.Text := 'DELETE FROM ' + TableName;
    Query.ExecSQL;

    Query.Connection.BeginTrans;
    try
      for i := 0 to Items.Count - 1 do
      begin
        Line := Items[i]; // одна строка: {"id_good":1,"naim_good":"Товар 1","price_good":100.5}
        Line := StringReplace(Line, '{', '', []);
        Line := StringReplace(Line, '}', '', []);

        // Простейший парсинг
        SId := Copy(Line, Pos('"id_good":', Line) + 10, Pos(',', Line) - Pos('"id_good":', Line) - 10);
        Delete(Line, 1, Pos(',', Line));

        SName := Copy(Line, Pos('"naim_good":"', Line) + 13,
                      Pos('"', Copy(Line, Pos('"naim_good":"', Line) + 13, 100)) - 1);
        Delete(Line, 1, Pos('"price_good":', Line) - 1);

        SPrice := Copy(Line, Pos('"price_good":', Line) + 13, Length(Line));

        SPrice := StringReplace(SPrice, ',', '.', [rfReplaceAll]);

        ID := StrToIntDef(Trim(SId), 0);
        Price := StrToFloatDef(Trim(SPrice), 0, Fmt);

        Query.Close;
        Query.SQL.Text := Format(
          'INSERT INTO %s (%s, %s, %s) VALUES (:%s, :%s, :%s)',
          [TableName, FieldIdName, FieldNaimName, FieldPriceName,
           FieldIdName, FieldNaimName, FieldPriceName]
        );
        Query.Parameters.ParamByName(FieldIdName).Value := ID;
        Query.Parameters.ParamByName(FieldNaimName).Value := SName;
        Query.Parameters.ParamByName(FieldPriceName).Value := Price;
        Query.ExecSQL;
      end;

      Query.Connection.CommitTrans;
    except
      on E: Exception do
      begin
        Query.Connection.RollbackTrans;
        ShowMessage('Ошибка при импорте: ' + E.Message);
        Exit;
      end;
    end;
  finally
    Items.Free;
  end;

  Query.DisableControls;
  try
    Query.Close;
    Query.SQL.Text := 'SELECT * FROM ' + TableName;
    Query.Open;
  finally
    Query.EnableControls;
  end;
  ShowMessage('Импорт JSON завершён.');
end;
procedure LoadTextFromResource(const ResourceName: string;
RichTextEdit: TRichEdit);
var
  RS: TResourceStream;
  Text: string;
begin
  if not Assigned(RichTextEdit) then
  begin
    ShowMessage('Ошибка: компонент RichTextEdit не назначен.');
    Exit;
  end;
  RS := TResourceStream.Create(HInstance, ResourceName, RT_RCDATA);
  try
    // Определяем размер текста и читаем его из потока
    SetLength(Text, RS.Size);
    RS.ReadBuffer(Pointer(Text)^, RS.Size);

    // Очищаем содержимое RichTextEdit и загружаем текст
    RichTextEdit.Clear;
    RichTextEdit.Text := Text;
  finally
    // Освобождаем поток
    RS.Free;
  end;
end;

procedure FormatRichText(RichEdit: TRichEdit; FontSize: Integer; FontName: string;
  TextColor: TColor; BulletStyle: Boolean; ReadOnly: Boolean; ScrollBars: TScrollStyle);
var
  i: Integer;
  StartPos, EndPos: Integer;
begin
  // Проверяем, что компонент RichEdit передан
  if not Assigned(RichEdit) then
  begin
    ShowMessage('Компонент RichEdit не назначен.');
    Exit;
  end;

  // Устанавливаем шрифт и размер текста для всего документа
  RichEdit.Font.Name := FontName;
  RichEdit.Font.Size := FontSize;

  // Устанавливаем режим "только для чтения"
  RichEdit.ReadOnly := ReadOnly;

  // Устанавливаем полосы прокрутки
  RichEdit.ScrollBars := ScrollBars;

  // Разделяем текст на строки
  for i := 0 to RichEdit.Lines.Count - 1 do
  begin
    // Определяем позиции начала и конца строки
    StartPos := RichEdit.Perform(EM_LINEINDEX, i, 0);
    EndPos := StartPos + Length(RichEdit.Lines[i]);

    // Выделяем строку
    RichEdit.SelStart := StartPos;
    RichEdit.SelLength := EndPos - StartPos;

    // Устанавливаем цвет текста
    RichEdit.SelAttributes.Color := TextColor;

    // Если нужно добавить маркеры (буллеты)
    if BulletStyle then
    begin
      RichEdit.Paragraph.Numbering := nsBullet; // Включаем маркеры
    end
    else
    begin
      RichEdit.Paragraph.Numbering := nsNone; // Отключаем маркеры
    end;

    // Снимаем выделение
    RichEdit.SelLength := 0;
  end;
end;

procedure MakeStaticTextLookLikeLink(
  AForm: TForm;
  const StaticTextName: string;
  OnMouseEnterEvent: TNotifyEvent;
  OnMouseLeaveEvent: TNotifyEvent;
  OnClickEvent: TNotifyEvent
);
var
  StaticText: TStaticText;
begin
  // Находим компонент по имени
  StaticText := TStaticText(AForm.FindComponent(StaticTextName));
  if not Assigned(StaticText) then
  begin
    raise Exception.CreateFmt('Компонент TStaticText с именем "%s" не найден на форме "%s".', [StaticTextName, AForm.Name]);
  end;
  with StaticText do
  begin
    Font.Style := [fsUnderline];  // Подчеркивание
    Cursor := crHandPoint;        // Курсор в виде руки
    if VisitedStaticTexts.IndexOf(StaticTextName) >= 0 then
      Font.Color := clRed
    else
      Font.Color := clBlue;
    OnMouseEnter := OnMouseEnterEvent;
    OnMouseLeave := OnMouseLeaveEvent;
    OnClick := OnClickEvent;
  end;
end;

// Обработчик события OnClick
procedure StaticTextClick(Sender: TObject);
begin
  if Sender is TStaticText then
  begin
    // Добавляем имя ссылки в список "посещенных"
    VisitedStaticTexts.Add(TStaticText(Sender).Name);
    TStaticText(Sender).Font.Color := clRed;
  end;
end;

procedure AlignComponentsVertically(AContainer: TWinControl; Spacing: Integer = 5);
var
  i: Integer;
  CurrentTop: Integer;
  Component: TControl;
begin
  if not Assigned(AContainer) then
    raise Exception.Create('Контейнер не назначен.');

  // Начальная позиция для первого элемента
  CurrentTop := 0;

  // Перебираем все дочерние компоненты контейнера
  for i := 0 to AContainer.ControlCount - 1 do
  begin
    Component := AContainer.Controls[i];

    // Проверяем, что компонент видимый и может быть размещен
    if Component.Visible then
    begin
      // Устанавливаем позицию компонента
      Component.Top := CurrentTop;
      Component.Left := 0; // Выравниваем по левому краю

      // Обновляем текущую позицию для следующего компонента
      CurrentTop := CurrentTop + Component.Height + Spacing;
    end;
  end;

  // При необходимости можно обновить размер контейнера
  AContainer.Height := CurrentTop - Spacing;
end;

procedure CheckAndCreateHelpFolder;
var
  AppPath, FolderPath: string;
begin
  // Получаем путь к текущей папке приложения
  AppPath := ExtractFilePath(ParamStr(0));
  FolderPath := IncludeTrailingPathDelimiter(AppPath) + 'hlp_res';

  // Проверяем, существует ли папка
  if not DirectoryExists(FolderPath) then
  begin
    // Если папка не существует, создаём её
    if not CreateDir(FolderPath) then
      raise Exception.Create('Не удалось создать папку: ' + FolderPath);
  end;
  if DirectoryExists(FolderPath)  then
  begin
     // ShowMessage('folder exists');
      Exit;
  end;

end;
procedure SaveRichEditToFile(RichEdit: TRichEdit; SaveDialog: TSaveDialog);
var
  FileStream: TFileStream;
  RichEditText: string;
begin
  if not Assigned(RichEdit) then
    raise Exception.Create('Компонент TRichEdit не назначен.');
  if not Assigned(SaveDialog) then
    raise Exception.Create('Компонент TSaveDialog не назначен.');
  if SaveDialog.Execute then
  begin
    try
      RichEditText := RichEdit.Lines.Text;
      FileStream := TFileStream.Create(SaveDialog.FileName, fmCreate);
      try
        FileStream.WriteBuffer(Pointer(RichEditText)^, Length(RichEditText));
      finally
        FileStream.Free;
      end;
    except
      on E: Exception do
        ShowMessage('Ошибка при сохранении файла: ' + E.Message);
    end;
  end;
end;

procedure AppendRichEditToIniFile(RichEdit: TRichEdit; const FileName: string);
var
  FileStream: TFileStream;
  RichEditText: string;
  FilePath: string; // Полный путь к файлу
begin
  if not Assigned(RichEdit) then
    raise Exception.Create('Компонент TRichEdit не назначен.');

  // Формируем полный путь к файлу в папке hlp_res
  FilePath := IncludeTrailingPathDelimiter(ExtractFilePath(Application.ExeName))
  + 'hlp_res\' + FileName;

  // Получаем текст из RichEdit
  RichEditText := RichEdit.Lines.Text;

  // Если файл уже существует, открываем его для добавления данных
  if FileExists(FilePath) then
  begin
    FileStream := TFileStream.Create(FilePath, fmOpenWrite);
    try
      // Перемещаем указатель в конец файла
      FileStream.Seek(0, soFromEnd);

      // Добавляем текст в конец файла
      FileStream.WriteBuffer(Pointer(RichEditText)^, Length(RichEditText));
    finally
      FileStream.Free;
    end;
  end
  else
  begin
    // Если файл не существует, создаем новый файл и записываем текст
    FileStream := TFileStream.Create(FilePath, fmCreate);
    try
      FileStream.WriteBuffer(Pointer(RichEditText)^, Length(RichEditText));
    finally
      FileStream.Free;
    end;
  end;
end;
procedure LoadTextFromFile(const FileName: string; RichTextEdit: TRichEdit);
var
  FileStream: TStringList;
    var FilePath:String;
begin
  // Проверка, что компонент RichTextEdit назначен
  if not Assigned(RichTextEdit) then
  begin
    ShowMessage('Ошибка: компонент RichTextEdit не назначен.');
    Exit;
  end;

  // Формируем полный путь к файлу в папке hlp_res
   FilePath := IncludeTrailingPathDelimiter(ExtractFilePath(Application.ExeName))
   + 'hlp_res\' + FileName;

  // Проверяем существование файла
  if not FileExists(FilePath) then
  begin
    ShowMessage('Ошибка: файл "' + FilePath + '" не найден.');
    Exit;
  end;

  // Создаем объект TStringList для чтения текста из файла
  FileStream := TStringList.Create;
  try
    FileStream.LoadFromFile(FilePath); // Загружаем текст из файла

    // Очищаем содержимое RichTextEdit и загружаем текст
    RichTextEdit.Clear;
    RichTextEdit.Lines.Assign(FileStream);
  finally
    // Освобождаем объект TStringList
    FileStream.Free;
  end;
end;
procedure GenerateMathQuiz(CaptchaLabel: TLabel; ResultLabel: TStaticText);
var
  Num1, Num2: Integer;
begin
  Randomize;

  // Генерация случайных чисел
  Num1 := Random(10);
  Num2 := Random(10);

  // Настройка метки с математическим выражением
  with CaptchaLabel do
  begin
    Caption := IntToStr(Num1) + ' + ' + IntToStr(Num2);
    Font.Size := RandomRange(12, 20); // Случайный размер шрифта
    Font.Color := RGB(Random(256), Random(256), Random(256)); // Случайный цвет
    Font.Style := [fsBold]; // Жирный шрифт
  end;

  // Вывод вопроса в ResultLabel
  ResultLabel.Caption := 'Сколько будет ' + CaptchaLabel.Caption + '?';
end;
procedure FormatPanelCaption(const PanelName: string; AForm: TForm;
  FontName: string; FontSize: Integer; FontColor: TColor);
var
  Component: TComponent;
  Panel: TPanel;
begin
  // Находим компонент по имени в контексте формы
  Component := AForm.FindComponent(PanelName);

  // Проверяем, что компонент найден и является TPanel
  if not Assigned(Component) or not (Component is TPanel) then
  begin
    raise Exception.CreateFmt('Компонент "%s" не найден или не является TPanel.', [PanelName]);
  end;

  // Приводим компонент к типу TPanel
  Panel := TPanel(Component);

  // Устанавливаем параметры шрифта
  if Assigned(Panel.Font) then
  begin
    Panel.Font.Name := FontName;   // Устанавливаем название шрифта
    Panel.Font.Size := FontSize;   // Устанавливаем размер шрифта
    Panel.Font.Color := FontColor; // Устанавливаем цвет шрифта
  end;

  // Обновляем текст Caption (необязательно)
  Panel.Caption := Panel.Caption;
end;
 procedure CheckMathQuizAnswer(CaptchaLabel: TLabel; InputBox: TLabeledEdit;
 ResultLabel: TStaticText);
var
  Num1, Num2, CorrectAnswer, UserAnswer: Integer;
  InputStr: string;
begin
  // Получение чисел из CaptchaLabel
  Num1 := StrToInt(Copy(CaptchaLabel.Caption, 1, Pos(' + ', CaptchaLabel.Caption) - 1));
  Num2 := StrToInt(Copy(CaptchaLabel.Caption, Pos(' + ', CaptchaLabel.Caption) + 3, Length(CaptchaLabel.Caption)));

  // Вычисление правильного ответа
  CorrectAnswer := AddNumbers(Num1, Num2);

  // Получение введенного текста
  InputStr := Trim(InputBox.Text);

  // Проверка, что пользователь ввел что-то
  if InputStr = '' then
  begin
    ResultLabel.Caption := 'Ошибка: вы не ввели ответ.';
    Exit;
  end;

  // Преобразование введенного текста в число
  try
    UserAnswer := StrToInt(InputStr);
  except
    on E: EConvertError do
    begin
      ResultLabel.Caption := 'Ошибка: введенные данные не являются числом.';
      Exit;
    end;
  end;
  if UserAnswer = CorrectAnswer then
    ResultLabel.Caption := 'Правильно!'
  else
    ResultLabel.Caption := Format('Неправильно! Правильный ответ: %d.', [CorrectAnswer]);
end;
function get_rnd_char(symcount:Integer):string;
var
  x:symmx;
  i:Integer;
  Symstr:string;
begin
if symcount <= 0 then
  begin
    Result := '';
    Exit;
  end;
  Randomize;
Symstr:='';
for I:=1 to symcount do
begin
x[i]:=Random(59)+64;
end;
for I := 1 to symcount do
begin
Symstr:=Symstr+Chr(x[i]);
end;
Result:=Trim(Symstr);
end;

initialization
  VisitedStaticTexts := TStringList.Create;
finalization
if hAniCursor <> 0 then
    DestroyCursor(hAniCursor);
    VisitedStaticTexts.Free;
end.
